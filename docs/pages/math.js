const normalize=(d,x)=>(x||(x=distance(d)),{x:d.x/x,y:d.y/x}),add=(d,x)=>({x:x.x+d.x,y:x.y+d.y}),mod=(d,x)=>({x:(d.x+1)%x,y:(d.y+1)%x}),del=(d,x)=>({x:d.x-x.x,y:d.y-x.y}),mul=(d,x)=>({x:d.x*x,y:d.y*x}),delta=(d,x)=>({x:x.x-d.x,y:x.y-d.y}),distance_sqrd=(d,x)=>{void 0===x&&(x={x:0,y:0});const y=delta(d,x);return y.x*y.x+y.y*y.y},distance=(d,x)=>Math.sqrt(distance_sqrd(d,x)),dot=(d,x)=>d.x*x.x+d.y*x.y,collision_response=(d,x)=>{const y={x:d.dp.x-x.dp.x,y:d.dp.y-x.dp.y},t={x:d.np.x-x.np.x,y:d.np.y-x.np.y};let a=dot(y,t),r=distance({x:0,y:0},t),s=1*a/(r*r);return{x:t.x*s,y:t.y*s}},wrap_around=(d,x)=>{let y=1.25,t=1.5,a={x:(d.x+y)%1,y:(d.y+y)%1},r={x:(x.x+y)%1,y:(x.y+y)%1},s={x:(d.x+t)%1,y:(d.y+t)%1},n={x:(x.x+t)%1,y:(x.y+t)%1};const e=distance_sqrd(d,x),o=distance_sqrd(a,r),c=distance_sqrd(s,n);return e<o?e<c?{a:d,b:x,d_sqrd:e}:{a:s,b:n,d_sqrd:c}:o<c?{a,b:r,d_sqrd:o}:{a:s,b:n,d_sqrd:c}},rotate=(d,x,y)=>{y=2*Math.PI*y;const t=x.x-d.x,a=x.y-d.y,r=Math.cos(y),s=Math.sin(y);return{x:d.x+t*r-a*s,y:d.y+a*r+t*s}},distance_wrap_arround=(d,x)=>Math.sqrt(wrap_around(d,x).d_sqrd);export{delta,distance_sqrd,distance,dot,mul,collision_response,wrap_around,normalize,rotate,add,del,mod};